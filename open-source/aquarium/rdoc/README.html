<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>README - Aquarium</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">




<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>

  <ul class="link-list" role="directory">
    <li><a href="#label-Aquarium">Aquarium</a>
    <li><a href="#label-SOMEBODY+ADOPT+ME-21-21">SOMEBODY ADOPT ME!!</a>
    <li><a href="#label-Supported+Ruby+Versions+-28and+Caveats-29">Supported Ruby Versions (and Caveats)</a>
    <li><a href="#label-Why+Is+an+AOP+Framework+Useful+in+Ruby-3F">Why Is an AOP Framework Useful in Ruby?</a>
    <li><a href="#label-Terminology">Terminology</a>
    <li><a href="#label-Known+Limitations">Known Limitations</a>
    <li><a href="#label-Differences+With+Other+Ruby+AOP+Toolkits">Differences With Other Ruby AOP Toolkits</a>
    <li><a href="#label-Differences+With+AspectJ+Behavior">Differences With AspectJ Behavior</a>
    <li><a href="#label-Examples">Examples</a>
    <li><a href="#label-Packages">Packages</a>
    <li><a href="#label-Installation">Installation</a>
    <li><a href="#label-Building+the+Aquarium+gem">Building the Aquarium gem</a>
    <li><a href="#label-Running+Aquarium-27s+RSpec+Specs">Running Aquarium&#39;s RSpec Specs</a>
    <li><a href="#label-Acknowledgments">Acknowledgments</a>
  </ul>
</div>


  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="./CHANGES.html">CHANGES</a>
  
    <li><a href="./MIT_LICENSE.html">MIT_LICENSE</a>
  
    <li><a href="./README.html">README</a>
  
    <li><a href="./UPGRADE.html">UPGRADE</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page README">

<h2 id="label-Aquarium"><a href="Aquarium.html"><code>Aquarium</code></a><span><a href="#label-Aquarium">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p><a href="Aquarium.html"><code>Aquarium</code></a> is a toolkit for Aspect-Oriented Programming (AOP) whose goals include:</p>
<ul><li>
<p>A powerful “pointcut” language for specifying where to apply aspects, comparable to the pointcut language in AspectJ for Java.</p>
</li><li>
<p>Management of concurrent aspects (i.e., those acting on the same “join points”).</p>
</li><li>
<p>Adding and removing aspects dynamically.</p>
</li><li>
<p>A user-friendly DSL.</p>
</li><li>
<p>Support for advising Java types through JRuby.</p>
</li></ul>

<h3 id="label-SOMEBODY+ADOPT+ME-21-21">SOMEBODY ADOPT ME!!<span><a href="#label-SOMEBODY+ADOPT+ME-21-21">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>While I&#39;ve enjoyed working on <a href="Aquarium.html"><code>Aquarium</code></a>, I no longer do Ruby development. I just don&#39;t have the time to keep updating <a href="Aquarium.html"><code>Aquarium</code></a> as Ruby evolves. There are plenty of deprecation warnings now when you build <a href="Aquarium.html"><code>Aquarium</code></a> and JRuby support has been spotty since <a href="Aquarium.html"><code>Aquarium</code></a> v0.6.0.</p>

<h3 id="label-Supported+Ruby+Versions+-28and+Caveats-29">Supported Ruby Versions (and Caveats)<span><a href="#label-Supported+Ruby+Versions+-28and+Caveats-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Aquarium.html"><code>Aquarium</code></a> v0.7.0 was tested with Ruby 2.6.3p62 (2019-04-16 revision 67580) and JRuby 9.2.7.0 (Ruby 2.5.3) 2019-04-09 8a269e3. There are many deprecation warnings about constants that have been renamed, all of which appear to be in old libraries still used by <a href="Aquarium.html"><code>Aquarium</code></a>.</p>

<p><a href="Aquarium.html"><code>Aquarium</code></a> v0.6.0 supports only Ruby 2.0.0p247. JRuby 1.7.4 (Ruby 1.9.3p392) does <strong>not</strong> currently pass all the custom Java specs in the `jruby/spec` directory, which specifically test working with Java classes. However, JRuby does pass all the Ruby specs in the `spec` directory. I didn&#39;t want to release v0.6.0 with the Java-specific specs not working, but I didn&#39;t have time to resolve the issues. Patches are welcome.</p>

<p>If you need support for even earlier versions of Ruby and JRuby, use <a href="Aquarium.html"><code>Aquarium</code></a> v0.5.0.</p>

<h3 id="label-Why+Is+an+AOP+Framework+Useful+in+Ruby-3F">Why Is an AOP Framework Useful in Ruby?<span><a href="#label-Why+Is+an+AOP+Framework+Useful+in+Ruby-3F">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Ruby&#39;s metaprogramming facilities already provide some of the capabilities for which static-language AOP toolkits like AspectJ are typically used. With Ruby, you can easily add new methods and attributes to existing classes and objects. You can alias and redefine existing methods, which provides the method interception and “wrapping” needed to extend or modify existing behavior.</p>

<p>However, what is missing in Ruby is an expressive language for describing systemic modifications, a so-called “pointcut language”. If you have simple needs for method interception and wrapping, then <a href="Aquarium.html"><code>Aquarium</code></a> will be overkill. However, if you have system-wide concerns that cross the boundaries of many objects, then an AOP tookit like <a href="Aquarium.html"><code>Aquarium</code></a> can help you implement these concerns in a more modular way.</p>

<p>So, if you are designing with aspects, wouldn&#39;t you like to write your code using the same “language”? Without AOP support, you have to map your aspect designs to metaprogramming idioms, which will often be slower to implement and harder to maintain. Imagine writing objects without native support for OOP!</p>

<h3 id="label-Terminology">Terminology<span><a href="#label-Terminology">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Several terms are used in the AOP community.</p>
<ul><li>
<p>Join Point - A point of execution in a program where “advice” might be invoked.</p>
</li><li>
<p>Pointcut - (yes, one word…) A set of join points of particular interest, like a query over all join points in the system.</p>
</li><li>
<p>Advice - The behavior invoked at a join point. There are several kinds of advice:</p>
<ul><li>
<p>Before advice - Advice invoked before the actual join point is invoked.</p>
</li><li>
<p>After returning advice - Advice invoked after the join point executes successfully.</p>
</li><li>
<p>After raising advice - Advice invoked only after the join point raises an exception.</p>
</li><li>
<p>After advice - Advice invoked after the join point executes successfully or raises an exception.</p>
</li><li>
<p>Around advice - Advice invoked instead of the join point. The around advice must choose whether or not to invoke the join point by calling a special “proceed” method. Otherwise, the join point is NOT executed.</p>
</li></ul>
</li></ul>

<p>Only around advice can prevent execution of the join point, except for the special case where before advice raises an exception.</p>

<h3 id="label-Known+Limitations">Known Limitations<span><a href="#label-Known+Limitations">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p>You cannot advice “String”, “Symbol” or instances there of, because trying to specify either one will be confused with naming a type.</p>
</li><li>
<p>Concurrent advice on type AND advice on objects of the type can&#39;t be removed cleanly.</p>
</li><li>
<p>The pointcut language is still limited, compared to AspectJ&#39;s. See also the comparison with AspectJ behavior next.</p>
</li><li>
<p>There are limitations when advising Java types through JRuby. The separate RSpec suite in the “jruby” directory documentations the details on how to use <a href="Aquarium.html"><code>Aquarium</code></a> with JRuby-wrapped Java types and the limitations thereof. Here we summarize what works and what doesn&#39;t:</p>
<ul><li>
<p><a href="Aquarium.html"><code>Aquarium</code></a> advice on a method in a Java type will only be invoked when the method is called directly from Ruby.</p>
</li><li>
<p>To have the advice invoked when the method is called from either Java or Ruby, it is necessary to create a subclass of the Java type in Ruby and an override of the method, which can just call “super”. Note that it will be necessary for instances of this Ruby type to be used throughout, not instances of a Java parent type.</p>
</li><li>
<p>BUG #18325: If you have Ruby subclasses of Java types <strong>and</strong> you advise a Java method in the hierarchy using @:types_and_descendents =&gt; MyJavaBaseClassOrInterface@ <strong>and</strong> you call unadvise on the aspect, the advice “infrastructure” is not correctly removed from the Ruby types. Workaround: Only advise methods in Ruby subclasses of Java types where the method is explicitly overridden in the Ruby class. (The spec and the “Rubyforge bug report”:<a href="http://rubyforge.org/tracker/index.php?func=detail&aid=18325&group_id=4281&atid=16494">rubyforge.org/tracker/index.php?func=detail&aid=18325&group_id=4281&atid=16494</a> provide examples.)</p>
</li><li>
<p>BUG #18326: Normally, you can use either Java- or Ruby-style method names (e.g., “doSomething” vs. “do_something”), for Java types. However, if you write an aspect using the Java-style for a method name and a Ruby subclass of the Java type where the method is actually defined (i.e., the Ruby class doesn&#39;t override the method), it appears that the JoinPoint was advised, but the advice is never called. Workaround: Use the Ruby-style name in this scenario.</p>
</li></ul>
</li></ul>

<h3 id="label-Differences+With+Other+Ruby+AOP+Toolkits">Differences With Other Ruby AOP Toolkits<span><a href="#label-Differences+With+Other+Ruby+AOP+Toolkits">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>There are several other AOP toolkits for Ruby that precede <a href="Aquarium.html"><code>Aquarium</code></a>. The most notable are AspectR and the aspect capabilities in the Facets toolkit. There are also Ruby 2.0 proposals to add method wrappers for “before”, “after” and “wrap” behavior.</p>

<p>The goal of <a href="Aquarium.html"><code>Aquarium</code></a> is to provide a superset of the functionality provided by these other toolkits. <a href="Aquarium.html"><code>Aquarium</code></a> is suitable for non-trivial and large-scale aspect-oriented components in systems. <a href="Aquarium.html"><code>Aquarium</code></a> will be most valuable for systems where aspects might be added and removed dynamically at runtime and systems where nontrivial pointcut descriptions are needed, requiring a full-featured pointcut language (as discussed above…). For less demanding needs, the alternatives are lighter weight and hence may be more appropriate.</p>

<h3 id="label-Differences+With+AspectJ+Behavior">Differences With AspectJ Behavior<span><a href="#label-Differences+With+AspectJ+Behavior">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Many of AspectJ&#39;s features are not currently supported by <a href="Aquarium.html"><code>Aquarium</code></a>, but some of them are planned for future releases.</p>
<ul><li>
<p>Attribute reading and writing join points are not supported. The :attributes and :attributes_options parameters (and their synonyms) for Aspect.new are actually “syntactic sugar” for the corresponding accessor methods.</p>
</li><li>
<p>More advanced AspectJ pointcut language features are not supported, such as the runtime pointcut designators like “if” conditionals and “cflow” (context flow) and the compile time “within” and “withincode” designators. Most of AspectJ pointcut language features are planned, however.</p>
</li><li>
<p>While AspectJ provides “intertype declaration” capabilities (i.e., adding state and behavior to existing classes), Ruby&#39;s native metaprogramming support satisfies this need. There may be convenience hooks added in a future release, however.</p>
</li><li>
<p>User defined advice precedence is not supported. However, advice precedence is unambiguous; the last aspects created while modules are loaded at runtime have higher precedence than earlier aspects. Ensuring a particular order is not always easy, of course.</p>
</li></ul>

<p>However, <a href="Aquarium.html"><code>Aquarium</code></a> does have a few advantages over AspectJ, especially when advising Java types when running in JRuby.</p>
<ul><li>
<p><a href="Aquarium.html"><code>Aquarium</code></a> can add and remove advice dynamically, at runtime.</p>
</li><li>
<p><a href="Aquarium.html"><code>Aquarium</code></a> can advise individual objects, not just classes.</p>
</li><li>
<p><a href="Aquarium.html"><code>Aquarium</code></a> can advise JDK classes. AspectJ can also do this, but not by default.</p>
</li><li>
<p><a href="Aquarium.html"><code>Aquarium</code></a> supports named advice that can be defined separately from the aspects that use the advice.</p>
</li><li>
<p><a href="Aquarium.html"><code>Aquarium</code></a> can advise ancestor (parent) types, not just derived (descendent) types of specified types.</p>
</li></ul>

<p>Note: at the time of this writing (V0.4.0 release), there is an important limitation of <a href="Aquarium.html"><code>Aquarium</code></a> when used with java code; it appears that advice is only invoked if an advised method is called directly from Ruby code. If the advised method is called by other Java code, the advice is <strong>not</strong> invoked. Whether or not this limitation can be removed is under investigation.</p>

<p>Also, as of V0.4.0, the interaction behavior of <a href="Aquarium.html"><code>Aquarium</code></a> and AspectJ or Spring aspects has not been investigated.</p>

<h3 id="label-Examples">Examples<span><a href="#label-Examples">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Several complete examples are provided in the “examples” directory.</p>

<p>In most cases, you can either declare the appropriate classes or use the optional DSL, which adds convenience methods to classes, objects, or even <a href="Object.html"><code>Object</code></a> itself. The API also supports many synonyms for things like types, objects, and methods. The best place to see the full list of synonyms is the output of “pointcut_spec.rb”.</p>

<p>Here is an example that traces invocations of all public instance methods (included inherited ones) of the classes or modules Foo and Bar.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;aquarium&#39;</span>
<span class="ruby-constant">Aspect</span>.<span class="ruby-identifier">new</span> <span class="ruby-value">:around</span>, <span class="ruby-value">:calls_to</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">:all_methods</span>, <span class="ruby-value">:on_types</span> <span class="ruby-operator">=&gt;</span> [<span class="ruby-constant">Foo</span>, <span class="ruby-constant">Bar</span>] <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">join_point</span>, <span class="ruby-identifier">object</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">p</span> <span class="ruby-node">&quot;Entering: #{join_point.target_type.name}##{join_point.method_name} for object #{object}&quot;</span>
        <span class="ruby-identifier">result</span> = <span class="ruby-identifier">join_point</span>.<span class="ruby-identifier">proceed</span>
        <span class="ruby-identifier">p</span> <span class="ruby-node">&quot;Leaving: #{join_point.target_type.name}##{join_point.method_name} for object #{object}&quot;</span>
        <span class="ruby-identifier">result</span>  <span class="ruby-comment"># block needs to return the result of the &quot;proceed&quot;!</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The advice to execute at each join point is the block. The pointcut is the set of all public instance methods in Foo and Bar. (There are additional options available for specifying class methods, protected methods, excluding inherited (ancestor) methods, etc.) Here is the same example using the convenience DSL that adds aspect methods to <a href="Object.html"><code>Object</code></a> (available only if you require aquarium/dsl/object_dsl&#39;, since other toolkits, like Rails, define similar methods on <a href="Object.html"><code>Object</code></a>!).</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;aquarium/dsl/object_dsl&#39;</span>
<span class="ruby-identifier">around</span> <span class="ruby-value">:calls_to</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">:all_methods</span>, <span class="ruby-value">:on_types</span> <span class="ruby-operator">=&gt;</span> [<span class="ruby-constant">Foo</span>, <span class="ruby-constant">Bar</span>] <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">join_point</span>, <span class="ruby-identifier">object</span>, <span class="ruby-operator">*</span><span class="ruby-identifier">args</span><span class="ruby-operator">|</span>
        <span class="ruby-identifier">p</span> <span class="ruby-node">&quot;Entering: #{join_point.target_type.name}##{join_point.method_name} for object #{object}&quot;</span>
        <span class="ruby-identifier">result</span> = <span class="ruby-identifier">join_point</span>.<span class="ruby-identifier">proceed</span>
        <span class="ruby-identifier">p</span> <span class="ruby-node">&quot;Leaving: #{join_point.target_type.name}##{join_point.method_name} for object #{object}&quot;</span>
        <span class="ruby-identifier">result</span>  <span class="ruby-comment"># block needs to return the result of the &quot;proceed&quot;!</span>
<span class="ruby-keyword">end</span>
</pre>

<p>See “examples/method_tracing_example.rb” for a more detailed version of this example.</p>

<p>If you don&#39;t want to add these methods to <a href="Object.html"><code>Object</code></a>, you can also add them individually to modules, classes, or objects:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;aquarium&#39;</span>
<span class="ruby-operator">...</span>
<span class="ruby-keyword">module</span> <span class="ruby-constant">MyModule</span>
        <span class="ruby-identifier">include</span> <span class="ruby-constant">Aquarium</span><span class="ruby-operator">::</span><span class="ruby-constant">DSL</span>
<span class="ruby-keyword">end</span>

<span class="ruby-keyword">class</span> <span class="ruby-constant">MyClass</span>
        <span class="ruby-identifier">include</span> <span class="ruby-constant">Aquarium</span><span class="ruby-operator">::</span><span class="ruby-constant">DSL</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">my_object</span> = <span class="ruby-constant">MyOtherClass</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">my_object</span>.<span class="ruby-identifier">extend</span> (<span class="ruby-constant">Aquarium</span><span class="ruby-operator">::</span><span class="ruby-constant">DSL</span>)
</pre>

<p>If you use the DSL inside a class and omit the :type(s) and :object(s) options, “self” is assumed.</p>

<pre>class Foo
        include Aquarium::DSL
        ...
        def critical_operation *args
                ...
        end
end
...
class Foo
        around :critical_operation do |join_point, object, *args|
                p &quot;Entering: Foo#critical_operation&quot;
                result = join_point.proceed
                p &quot;Leaving: Foo#critical_operation&quot;
                result
        end
end</pre>

<p>It is important to note that aspect “instances” usually behave like class (static) variables, in terms of the lifetime of their effects. In the example shown, class Foo is permanently modified to do the print statements shown for all “critical methods”, unless you save the result of calling “around” to a variable, e.g., critical_operation_logging, and you explicitly call “critical_operation_logging.unadvise” at some future time. Put another way, the effects scope just like changes made when you reopen a class or module.</p>

<p>A common mistake is to create an aspect in an initialize method and assign it to an attribute. This usually means that you are creating long-lived, redundant aspects every time an instance of your class is created. The aspect modifications remain in effect even when the instances themselves are garbage collected!</p>

<p>Here are some more succinct examples, illustrating the API (using the DSL methods) and some of the various synonyms for methods, types, etc.</p>

<p>You can pass in pointcuts defined elsewhere:</p>

<pre>my_pointcut = Pointcut.new :invocations_of =&gt; /^do_/, :within_types =&gt; /Foo::Bar::/
around :pointcuts =&gt; my_pointcut do |jp, obj, *args| ...         # Pass in a pointcut
around :pointcuts =&gt; [my_pointcut, ...] do |jp, obj, *args| ...  # Pass in a pointcut array</pre>

<p>As a convenience, since a JoinPoint is a Pointcut with one element, you can pass a JoinPoint object where Pointcut objects are expected:</p>

<p>my_join_point1 = JoinPoint.new :type =&gt; Foo::Bar, :method =&gt; do_this my_join_point2 = JoinPoint.new :type =&gt; Foo::Bar, :method =&gt; do_that around :pointcuts =&gt; my_join_point1 do |jp, obj, *args| … around :pointcuts =&gt; [my_join_point1, my_join_point2, …] do |jp, obj, *args| …</p>

<p>You can specify a single type, a type name, a type regular expression, or an array of the same. Note that :type and :types are synonymous. Use the singular form for better readability when you are specifying just one type. Other synonyms include :on_types, :within_types, and :in_types, plus the singular forms.</p>

<pre>around :type = A, ...
around :type = &quot;A&quot;, ...
around :types =&gt; [A, B, ...], ...
around :types =&gt; %w[A, B, ...], ...
around :types =&gt; /A::.*Helper$/, ...
around :types =&gt; [/A::.*Helper$/, /B::Foo.*/], ...</pre>

<p>Everywhere “type” is used, you can substitute “class”, “classes”, “module”, or “modules”. Note that they are treated as synonyms; there is currently no enforcement that the values passed with “:class”, for example, are actually classes, not modules.</p>

<p>There are also several prepositional prefixes allowed for any of the synonyms. E.g.,</p>

<pre>around :for_types = A, ...
around :on_types = A, ...
around :in_types = A, ...
around :within_types = A, ...</pre>

<p>Using the plural versions of the synonyms with method specifications sometimes read better:</p>

<pre>around :calls_to =&gt; :all_methods, :on_types =&gt; [A, B, ...], ...
around :calls_to =&gt; :all_methods, :in_types =&gt; [A, B, ...], ...
around :calls_to =&gt; :all_methods, :within_types =&gt; [A, B, ...], ...</pre>

<p>You can specify types and their descendents (subclasses or included modules) or ancestors. The same synonym prefixes for :types and :type also apply.</p>

<pre>around :type_and_ancestors = A, ...
around :types_and_ancestors = A, ...
around :type_and_descendents = A, ...
around :types_and_descendents = A, ...
around :classes_and_descendents = A, ...
around :modules_and_descendents = A, ...</pre>

<p>Some of the synonyms:</p>

<pre>around :calls_to =&gt; :all_methods, :on_types_and_ancestors = A, ...
around :calls_to =&gt; :all_methods, :in_types_and_ancestors = A, ...
around :calls_to =&gt; :all_methods, :within_types_and_ancestors = A, ...
and similarly for descendents</pre>

<p>You can specify a single object or an array of objects. As for :types, you can use :object, :objects, :on_objects, :within_object, :in_objects, and the singular forms synonymously.</p>

<pre>a1 = A.new
a2 = A.new
around :object = a1, ...
around :objects =&gt; [a1, a2], ...</pre>

<p>Some of the synonyms:</p>

<pre>around :calls_to =&gt; :all_methods, :on_objects = [a1, a2], ...
around :calls_to =&gt; :all_methods, :in_objects = [a1, a2], ...
around :calls_to =&gt; :all_methods, :within_objects = [a1, a2], ...</pre>

<p>If no types or objects are specified, the object defaults to “self”. However, this default is only supported when using the DSL to create an aspect, e.g.,</p>

<pre>class MyClass
        include Aquarium::DSL
        def doit; ...; end

        around :method =&gt; doit, ...   # Implicit :object =&gt; self, i.e., MyClass
end</pre>

<p>You can specify a single method symbol (name), a regular expression, or an array of the same. The synonyms for :methods include :method, :calls_to, :invoking, :invocations_of, and :sending_messages_to. The special keywords :all and :all_methods mean match all methods, subject to the :method_options discussed next.</p>

<pre>around :method = :all_methods, ...
around :method = :foo, ...
around :methods = [:foo, :bar, :baz], ...
around :methods = /^foo/, ...
around :methods = [/^foo/, /bar$/], ...</pre>

<p>Using the synonyms:</p>

<pre>around :calls_to = :all_methods, ...
after  :invoking = :all_methods, ...
after  :invocations_of = :all_methods, ...
after  :sending_messages_to = :all_methods, ...
after  :within_methods = :all_methods, ...</pre>

<p>You can specify method options. By default, public instance methods only are matched. Note that :methods =&gt; :all or :all_methods with no method options matches all public instance methods, including ancestor (inherited and included module) methods. For all the method options (except for :exclude_ancestor_methods), you can append the suffix “_methods”. You can also use the :restrict_methods_to synonym for :method_options.</p>

<pre>around :methods = /foo/, :method_options =&gt; [:instance], ...  # match instance methods (default)
around :methods = /foo/, :method_options =&gt; [:class], ...     # match class methods
around :methods = /foo/, :method_options =&gt; [:public, :protected, :private], ...
        # match public, protected, and private instance methods
around :methods = /foo/, :method_options =&gt; [:singleton], ... # match singleton methods
around :methods = /foo/, :method_options =&gt; [:exclude_ancestor_methods], ...
        # ignore methods defined in ancestors, inherited classes and included modules</pre>

<p>With synonyms:</p>

<pre>around :calls_to = /foo/, :restricting_methods_to =&gt; [:singleton_methods], ...</pre>

<p>You can specify attributes, which are actually convenience methods for the attribute accessors. They work very much like the :method options. Note that :all is NOT supported in this case. The available synonyms are slightly more complicated, as shown in these examples.</p>

<pre>around :attribute  = :foo, ...                                 # defaults to methods #foo and #foo=
around :attributes = :foo, ...                                 # the same
around :accessing  = :foo, ...                                 # the same

around :attribute = :foo, :attribute_options =&gt; [:readers]...  # only matches #foo
around :reading   = :foo                                       # the same

around :attribute = :foo, :attribute_options =&gt; [:writers]...  # only matches #foo=
around :writing   = :foo                                       # the same

around :attributes = [:foo, :bar, :baz], ...
around :attributes = /^foo/, ...
around :attributes = [/^foo/, /bar$/], ...</pre>

<p>Again, it&#39;s important to remember that actually advising the attribute accesses is not done; it&#39;s the public accessor methods that are advised! This may change in a future release.</p>

<p>You can specify a “Pointcut” that encapsulates one or more pre-defined Pointcuts or JoinPoints.</p>

<pre>around :pointcut = pc, ...                                     # for pre-defined pointcut &quot;pc&quot;
around :pointcuts = [pc, ...], ...                             # for pre-defined pointcut list
around :pointcut = jp, ...                                     # for pre-defined join point &quot;jp&quot;
around :pointcuts = [jp, ...], ...                             # for pre-defined join point list
around :pointcut = {:type =&gt; T, :method =&gt; :m}, ...            # same as around :type =&gt; T, :method =&gt; :m, ..</pre>

<p>Using the plural versions of the synonyms, with method specifications so they read better:</p>

<pre>around :for_pointcuts =&gt; [pc1, pc2, ...], ...
around :on_pointcuts =&gt; [pc1, pc2, ...], ...
around :in_pointcuts =&gt; [pc1, pc2, ...], ...
around :within_pointcuts =&gt; [pc1, pc2, ...], ...</pre>

<p>Since V0.4.2, you can also specify “named” pointcuts, which are searched for just like methods in types (as discussed below). For example, if several classes in module “App” define class constant pointcuts named STATE_CHANGE, the following expression in an around advice aspect will match all of them:</p>

<pre class="ruby"><span class="ruby-identifier">around</span> <span class="ruby-value">:named_pointcuts</span> <span class="ruby-operator">=&gt;</span> { <span class="ruby-value">:constants_matching</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-value">:STATE_CHANGE</span>, <span class="ruby-value">:in_types</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-regexp">/App::.*/</span> } <span class="ruby-operator">...</span>
</pre>

<p>For the type specification, which is required, any valid option for the TypeFinder class is allowed.</p>

<p>You can also match on class variables, using “:class_variables_matching”. To match on either kind of definition, use just “:matching”. If no :*matching is specified, then any class constant or variable Pointcut found will be matched.</p>

<p>Here are the variaus :*matching options and their synonyms:</p>

<pre>around :named_pointcuts =&gt; { :constants_matching            =&gt; :STATE_CHANGE, ... } ...   # class constants only
around :named_pointcuts =&gt; { :constants_named               =&gt; :STATE_CHANGE, ... } ...
around :named_pointcuts =&gt; { :constants_with_names_matching =&gt; :STATE_CHANGE, ... } ...

around :named_pointcuts =&gt; { :class_variables_matching            =&gt; :STATE_CHANGE, ... } ...   # class variables only
around :named_pointcuts =&gt; { :class_variables_named               =&gt; :STATE_CHANGE, ... } ...
around :named_pointcuts =&gt; { :class_variables_with_names_matching =&gt; :STATE_CHANGE, ... } ...

around :named_pointcuts =&gt; { :matching            =&gt; :STATE_CHANGE, ... } ...   # class constants and variables
around :named_pointcuts =&gt; { :named               =&gt; :STATE_CHANGE, ... } ...
around :named_pointcuts =&gt; { :with_names_matching =&gt; :STATE_CHANGE, ... } ...</pre>

<p>The :*matching options take a name, regular expression or array of the same (you can mix names and regular expressions).</p>

<p>You can also use the following synonyms for :named_pointcuts:</p>

<pre>around :named_pointcut =&gt; {...}
around :for_named_pointcut =&gt; {...}
around :on_named_pointcut =&gt; {...}
around :in_named_pointcut =&gt; {...}
around :within_named_pointcut =&gt; {...}
around :for_named_pointcuts =&gt; {...}
around :on_named_pointcuts =&gt; {...}
around :in_named_pointcuts =&gt; {...}
around :within_named_pointcuts =&gt; {...}</pre>

<p>You can specifically exclude particular pointcuts, join points, types, objects, methods, or attributes. This is useful when you specify a list or regular expression of “items” to match and you want to exclude some of the items. Note that there is an open bug (#15202) that appears to affect advising types, unadvising the types, then advising objects of the same types. (This is not likely to happen a lot in real applications, but it shows up when running Aquarium&#39;s specs.)</p>

<pre>around ..., :exclude_pointcut = pc, ...
around ..., :exclude_pointcuts = [pc, ...]
around ..., :exclude_named_pointcut = {...}
around ..., :exclude_named_pointcuts = {...}
around ..., :exclude_join_point = jp, ...
around ..., :exclude_join_points = [jp, ...]
around ..., :exclude_type = t, ...
around ..., :exclude_types = [t, ...]
around ..., :exclude_type_and_ancestors = t, ...
around ..., :exclude_types_and_ancestors = [t, ...]
around ..., :exclude_type_and_descendents = t, ...
around ..., :exclude_types_and_descendents = [t, ...]
around ..., :exclude_object = o, ...
around ..., :exclude_objects = [o, ...]
around ..., :exclude_method = m, ...
around ..., :exclude_methods = [m, ...]
around ..., :exclude_attribute = a, ...
around ..., :exclude_attributes = [a, ...]</pre>

<p>All the same synonyms for :pointcuts, :named_pointcuts, :types, :objects, and :methods apply here as well (after the “exclude_” prefix).</p>

<p>You can advice methods before execution:</p>

<pre>before :types =&gt; ...</pre>

<p>You can advice methods after returning successfully (i.e., no exceptions were raised):</p>

<pre>after_returning :types =&gt; ...
after_returning_from :types =&gt; ...      # synonym</pre>

<p>You can advice methods after raising exceptions:</p>

<pre>after_raising :types =&gt; ...              # After any exception is thrown
after_raising_within :types =&gt; ...       # synonym
after_raising =&gt; MyError, :types =&gt; ...  # Only invoke advice if &quot;MyError&quot; is raised.
after_raising =&gt; [MyError1, MyError2], :types =&gt; ...
        # Only invoke advice if &quot;MyError1&quot; or &quot;MyError2&quot; is raised.</pre>

<p>You can advice methods after returning successfully or raising exceptions. (You can&#39;t specify a set of exceptions in this case.):</p>

<pre>after :types =&gt; ...
after_raising_within_or_returning_from : types =&gt;       # synonym</pre>

<p>You can advice methods both before after. This is different from around advice, where the around advice has to explicitly invoke the join point (using JoinPoint#proceed). Instead, the before-and-after methods are convenience wrappers around the creation of separate before advice and the corresponding after advice.</p>

<pre>before_and_after :types =&gt;, ...
before_and_after_returning :types =&gt;, ...
before_and_after_returning_from :types =&gt;, ...  # synonym
before_and_after_raising :types =&gt;, ...
before_and_after_raising_within :types =&gt;, ...  # synonym
before_and_after_raising_within_or_returning_from :types =&gt;, ...        # synonym</pre>

<p>If you pass a block to Aspect.new, it will be the advice. When invoked, the advice will be passed the following three arguments,</p>

<pre>1) the JoinPoint, which will contain a JoinPoint::Context object with useful context information,
2) the object being sent the current message, and
3) the parameters passed with the original message.</pre>

<p>Recall that a Proc doesn&#39;t check the number of arguments (while lambdas do), so if you don&#39;t care about any of the trailing parameters, you can leave them out of the parameter list. Recall that the other difference between the two is that a return statement in a Proc returns from the method that contains it. As rule, do NOT use return statements in advices!</p>

<pre>around :type =&gt; [...], :methods =&gt; :all do |join_point, object, *args|
  advice_to_execute_before_the_jp
  result = join_point.proceed   # Invoke the join point, passing *args implicitly (you can override...)
  advice_to_execute_after_the_jp
  result     # return the result of the &quot;proceed&quot;, unless you override the value.
end
around(:type =&gt; [...], :methods =&gt; :all) {|join_point, object, *args| ...}  # (...) necessary for precedence...</pre>

<p>In the example, we show that you must be careful to return the correct value, usually the value returned by “proceed” or a value created by the block itself.</p>

<p>Note, prior to V0.2.0, the advice argument list was |join_point, *args|. <a href="Aquarium.html"><code>Aquarium</code></a> will look for such obsolete signatures (by looking at the arity of the proc) and raise an exception, if found. This check will be removed in a future release.</p>

<p>Rather than passing a block as the advice, you can pass a previously-created Proc:</p>

<pre>around :type =&gt; [...], :methods =&gt; :all, :advice =&gt; advice
around :type =&gt; [...], :methods =&gt; :all, :advise_with =&gt; advice  # synonym for advice. Note the &quot;s&quot;!
around :type =&gt; [...], :methods =&gt; :all, :call =&gt; advice         # synonym for advice.
around :type =&gt; [...], :methods =&gt; :all, :invoke =&gt; advice       # synonym for advice.</pre>

<p>Finally, when running in JRuby, you can advise Java types! See the examples in the separate RSpec suite in the “jruby” directory and the discussion above concerning known limitations.</p>

<h3 id="label-Packages">Packages<span><a href="#label-Packages">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><a href="Aquarium/Aspects.html"><code>Aquarium::Aspects</code></a> contains the Aspect class and supporting classes Pointcut, JoinPoint, etc.</p>

<p><a href="Aquarium/Finders.html"><code>Aquarium::Finders</code></a> provides tools for locating types, objects, and methods in the runtime, using names, symbols, or regular expressions.</p>

<p><a href="Aquarium/Extensions.html"><code>Aquarium::Extensions</code></a> provides extensions to several Ruby core library routines.</p>

<p><a href="Aquarium/Utils.html"><code>Aquarium::Utils</code></a> provides general-purpose utilities for manipulating Strings, Sets, Hashes, etc. as well as some generic types.</p>

<p><a href="Aquarium/Extras.html"><code>Aquarium::Extras</code></a> provides add-ons for <a href="Aquarium.html"><code>Aquarium</code></a>, such as a Design by Contract implementation. These extras are NOT included when you require the general &#39;aquarium.rb&#39; file. You have to explicitly include &#39;aquarium/extras&#39; or one of the &#39;aquarium/extras/*&#39; if you want to use them.</p>

<h2 id="label-Installation">Installation<span><a href="#label-Installation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The simplest approach is to install the gem:</p>

<pre>gem install -y aquarium    # sudo may be required on non-Windows systems</pre>

<h2 id="label-Building+the+Aquarium+gem">Building the <a href="Aquarium.html"><code>Aquarium</code></a> gem<span><a href="#label-Building+the+Aquarium+gem">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you prefer to build the gem locally, clone from GitHub,</p>

<pre>git clone git://github.com/deanwampler/Aquarium.git</pre>

<p>Then do the following:</p>

<pre class="ruby"><span class="ruby-identifier">rake</span> <span class="ruby-identifier">install</span>
</pre>

<p>This builds the gem file, pkg/aquarium-x.y.z.gem, and installs it locally.</p>

<p>If you are a maintainer and want to upload a new version to RubyGems.org, first see [this page](<a href="https://guides.rubygems.org/make-your-own-gem">guides.rubygems.org/make-your-own-gem</a>/) for creating a `~/.gem/credentials` file, then run this command to publish a new version.</p>

<pre>gem push pkg/aquarium-0.7.0.gem</pre>

<p>At this time, with the demise of RubyForge, the docs and home page are temporarily hosted at <a href="https://deanwampler.github.io/open-source/aquarium/index.html">deanwampler.github.io/open-source/aquarium/index.html</a>. I&#39;ll move them to a better location soon. I build them by running `rake website`, then copying the entire output of `../doc/aquarium/out/` to my GitHub site under the `open-source/Aquarium` directory. TBD - move somewhere better!</p>

<h2 id="label-Running+Aquarium-27s+RSpec+Specs">Running Aquarium&#39;s RSpec Specs<span><a href="#label-Running+Aquarium-27s+RSpec+Specs">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In order to run Aquarium&#39;s full suite of specs (rake pre_commit) you must install the following gems and tools:</p>
<ul><li>
<p>rake          # Runs the build script</p>
</li><li>
<p>rspec         # Used instead of Test::Unit for TDD</p>
</li><li>
<p>rcov          # For running coverage checks</p>
</li><li>
<p>webgen        # Generates the static HTML website</p>
</li><li>
<p>bundler       # Gem manager</p>
</li><li>
<p>coderay       # Required by webgen</p>
</li><li>
<p>diff-lcs      # Required if you use the –diff switch</p>
</li><li>
<p>win32console  # Required by the –colour switch if you&#39;re on Windows</p>
</li><li>
<p>heckle        # Required if you use the –heckle switch</p>
</li><li>
<p>jruby         # Required if run the separate spec suite in the “jruby” directory</p>
</li></ul>

<p>Once those are all installed, you should be able to run the suite with the following steps:</p>
<ul><li>
<p>git clone git://github.com/deanwampler/Aquarium.git</p>
</li><li>
<p>cd aquarium</p>
</li><li>
<p>rake spec</p>
</li></ul>

<p>or</p>
<ul><li>
<p>rake spec_rcov  # also runs rcov</p>
</li></ul>

<p>Note that <a href="Aquarium.html"><code>Aquarium</code></a> itself - once built - doesn&#39;t have any dependencies outside the Ruby core and stdlib.</p>

<p>If you want to run the tests for the JRuby support, you must also have JRuby installed (see version information above). To run the specs for JRuby, use the command</p>
<ul><li>
<p>rake verify_jruby</p>
</li></ul>

<p>This command runs the standard <a href="Aquarium.html"><code>Aquarium</code></a> specs using JRuby instead of MRI, then runs a separate set of specs in the “jruby/spec” directory which test <a href="Aquarium.html"><code>Aquarium</code></a> with Java classes inside JRuby.</p>

<p>&gt; *<strong>WARNING:</strong>* Currently, not all JRuby-specific specs pass!</p>

<h3 id="label-Acknowledgments">Acknowledgments<span><a href="#label-Acknowledgments">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>My colleagues in the AOSD community, in particular those who developed AspectJ, have been a big inspiration.</p>

<p>The RSpec team, in particular David Chelimsky, have really inspired my thinking about what&#39;s possible in Ruby, especially in the realm of DSLs. I also cribbed parts of the RSpec Rake process ;)</p>

<p>Keita Yamaguchi contributed some key patches that enabled Ruby 1.9.3 and JRuby 1.6.7 support, in addition to the prior support for Ruby 1.8.7. These patches allowed me to final release version 0.5.X. Thank you!</p>

<p>Finally, a number of users have contributed valuable feedback. In particular, thanks to Brendan L., Matthew F., and Mark V.</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.2.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

